#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Dec 17 10:44:17 2020

@author: Enrico Regolin
"""

import torch
from model.platooning_energy import *


class Car_classic(Car):

    def __init__(self, device, **kwargs):
        
        allowed_keys = {'dist_low' : 2, 'dist_high' : 10}
        # initialize all allowed keys
        self.__dict__.update((key, allowed_keys[key]) for key in allowed_keys)
        # and update the given keys by their given values
        self.__dict__.update((key, value) for key, value in kwargs.items() if key in allowed_keys)

        self.ref_distance = self.dist_low + (self.dist_high-self.dist_low)/2
        self.previous_distance = None
        
        super().__init__(device)
        
        #self.vel = 0.0
        self.tc_lp = 0.5
        self.dist_thds = [1.5*self.dist_low, 2*self.dist_low]
        self.K_ctrl = .1*torch.tensor([2, .0002, 2])
        self.cum_error = self.previous_def_e_tq = torch.tensor(0)
        
        self.max_norm_val = 0.999

    def update(self, dt, current_distance):

        classic_norm_e_torque, classic_norm_br_torque = self.get_controller_input(dt, current_distance)
        super().update(dt=dt, norm_e_torque=classic_norm_e_torque, norm_br_torque=classic_norm_br_torque)
        return classic_norm_e_torque, classic_norm_br_torque
        
    def get_controller_input(self, dt, current_distance):
        
        error = self.ref_distance - current_distance
        self.cum_error = self.cum_error + error
        
        if self.previous_distance is None:
            vel_error = 0
        else:
            vel_error = torch.clamp((self.previous_distance - current_distance ) / dt , -20, 20)
        
        ctrl_law =  -( self.K_ctrl[0]*error +self.K_ctrl[1]* self.cum_error \
                      + self.K_ctrl[2]*vel_error )
        
        norm_e_torque = (1-self.tc_lp)*ctrl_law + \
            self.tc_lp*self.previous_def_e_tq
        
        norm_e_torque = torch.clamp(norm_e_torque, -self.max_norm_val , self.max_norm_val)
       
        norm_br_torque = 0
    
        if error > self.dist_thds[1] and vel_error > 0:
            norm_br_torque = self.max_norm_val
            norm_e_torque = -self.max_norm_val

        elif error > self.dist_thds[0] and vel_error > 0:
            norm_br_torque = (error - self.dist_thds[0]) / \
                (self.dist_thds[1]- self.dist_thds[0])
            norm_e_torque = -self.max_norm_val
        
        
        if not torch.is_tensor(norm_e_torque):
            norm_e_torque = torch.tensor(norm_e_torque)
            
        if not torch.is_tensor(norm_br_torque):
            norm_br_torque = torch.tensor(norm_br_torque)
            
        self.previous_def_e_tq = norm_e_torque
        self.previous_distance = current_distance

        return norm_e_torque, norm_br_torque


class Agent(Agent):

    def __init__(self, device, **kwargs):
        self._car = Car_classic(device, **kwargs)

    
    def update(self, distance, dt):
        """ Updates the physical state with the parameters
            generated by the NN.
        """
        
        self._car.update(dt=dt, current_distance= distance)
        

class Model_classic(Model):

    def __init__(self, param_generator, device="cpu", **kwargs):        
      self.agent = Agent(device, **kwargs)
      self.environment = Environment(device)

      self.agent.set_environment(self.environment)
      self.environment.set_agent(self.agent)

      self._param_generator = param_generator
      self.traces = None

    def step(self, env_input, distance, dt):
      """ Updates the physical world with the evolution of
          a single instant of time.
      """
      #print(f'model step: {agent_input[0]}')
      
      self.environment.update(parameters=env_input, dt=dt)
      self.agent.update(distance=distance, dt=dt)

      self.traces['dist'].append(self.agent.distance)
      self.traces['power'].append(self.agent.e_power)
      
        

#%%
    
if __name__ == "__main__":
    
    import numpy as np
    import matplotlib.pyplot as plt
    
    load_from_file = True
    
    device = torch.device("cpu")
    
    journey_length = 200
    
    n_sim = 4

    
    if load_from_file:
        import pickle
        with open('model/test_case.npy', 'rb') as f:
            save_dict = pickle.load(f) #, allow_pickle=True)
    
        veh_ref_pos = []
        for k in save_dict:
            veh_ref_pos.append(save_dict[k])  
    
        ref_vehicle_position = veh_ref_pos[k][0]
        ref_vehicle_speed = initial_speed = (veh_ref_pos[n_sim][2]-veh_ref_pos[n_sim][1])/dt
        
    else:
        ref_vehicle_position = 10 #m ahead of controlled vehicle
        initial_speed = 10
        ref_vehicle_speed = 20 #m/s
    
    dt = 0.05 #s
    
    
    
    current_distance = ref_vehicle_position

    follower = Car_classic(device, dist_low= 10, dist_high = 35)
    follower.velocity = torch.tensor(initial_speed)
    
    target_distance = follower.ref_distance

        
    # car position, car speed, vehicle position, vehicle speed
    state_storage = np.array([[0, initial_speed, ref_vehicle_position,ref_vehicle_speed]])
    # e torque, br torque
    ctrl_storage = np.array([[0, 0, target_distance - current_distance, 0, 0]])
    cum_energy = 0
    
    for i in range(journey_length-1):
                
        classic_norm_e_torque, classic_norm_br_torque = follower.update(dt, torch.tensor(current_distance))
    

        if load_from_file:
            ref_vehicle_speed  = (veh_ref_pos[n_sim][i+1]-veh_ref_pos[n_sim][i])/dt
            ref_vehicle_position = veh_ref_pos[n_sim][i+1]
            
        else:
            acc = 2*np.random.randn()
            ref_vehicle_speed += acc * dt
            ref_vehicle_speed = np.clip(ref_vehicle_speed, 5, 30)
            ref_vehicle_position += ref_vehicle_speed* dt
        
        power = follower.e_power.item()
        cum_energy += power*dt
        
        current_distance = ref_vehicle_position - follower.position.item()
        error = target_distance - current_distance
        
        state_storage = np.append(state_storage, np.array([[follower.position.item(), \
                            follower.velocity.item(),ref_vehicle_position, ref_vehicle_speed ]]), axis = 0)
        ctrl_storage = np.append(ctrl_storage, np.array([[classic_norm_e_torque.item(), classic_norm_br_torque.item() , error, power, cum_energy]]), axis = 0)
        
        #print(f'iteration {i}')
    

    fig1 = plt.figure()
    ax_0 = fig1.add_subplot(3,1,1)
    ax_1 = fig1.add_subplot(3,1,2)
    ax_2 = fig1.add_subplot(3,1,3)
    
    
    ax_0.plot(ctrl_storage[:,2])
    ax_0.plot(0*np.ones((journey_length,1)), 'k',linewidth=0.5)
    ax_0.plot(target_distance*np.ones((journey_length,1)), 'r')
    #ax_0.plot(-20*np.ones((journey_length,1)))
    ax_0.legend(['distancing error','reference','crash line' ])
    
    ax_1.plot(state_storage[:,2])
    ax_1.plot(state_storage[:,0])
    ax_1.legend(['leader pos','car position'])
    
    
    ax_2.plot(state_storage[:,3])
    ax_2.plot(state_storage[:,1])
    ax_2.legend(['leader vel','car vel'])
    
    fig1.savefig('state_signals.png')
    
    
    plt.show()
    
    fig2 = plt.figure()
    ax0 = fig2.add_subplot(3,1,1)
    ax1 = fig2.add_subplot(3,1,2)
    ax2 = fig2.add_subplot(3,1,3)
    
    ax0.plot(ctrl_storage[:,3])
    ax0.legend(['power'])
    
    ax1.plot(ctrl_storage[:,4])
    ax1.legend(['cum energy'])
    
    ax2.plot(ctrl_storage[:,0])
    ax2.plot(ctrl_storage[:,1])
    ax2.legend(['electric tq','brake tq'])
    
    fig2.savefig('ctrl_signals.png')
    
    plt.show()
    
    
    
    
    
    